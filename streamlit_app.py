# app.py
import streamlit as st
import pandas as pd
import time
import re
from io import BytesIO
from openai import OpenAI

# ‚Üí R√©cup√®re la cl√© depuis les Secrets Streamlit (jamais committ√©e)
client = OpenAI(api_key=st.secrets["OPENAI_API_KEY"])

st.set_page_config(page_title="AI Excel Processor", layout="wide")
st.title("üîß AI Excel Processor")

# 1) Upload & preview
uploaded = st.file_uploader("üìÇ Chargez votre fichier Excel", type=["xlsx"])
if not uploaded:
    st.stop()
df = pd.read_excel(uploaded, engine="openpyxl")
st.success(f"Fichier charg√© : {df.shape[0]} lignes √ó {df.shape[1]} colonnes")
st.dataframe(df, height=300)

# --- Pr√©pare session_state pour le prompt ---
if "prompt_text" not in st.session_state:
    st.session_state.prompt_text = ""

# 2) Zone de saisie du prompt
st.markdown("### ‚úèÔ∏è R√©digez votre prompt")
st.text_area(
    "Prompt (utilisez {Colonne} pour ins√©rer un placeholder)",
    height=200,
    key="prompt_text"
)

# 3) Insertion de placeholders
st.markdown("### ‚ûï Ajouter un placeholder")

# 3A) S√©lection simple d'une colonne
col_to_insert = st.selectbox("S√©lectionnez la colonne :", df.columns, key="select_placeholder")
def insert_placeholder():
    st.session_state.prompt_text += f"{{{col_to_insert}}}"
st.button("Ajouter `{Colonne}`", on_click=insert_placeholder)

# 3B) S√©lection multiple de colonnes
cols_to_insert = st.multiselect(
    "S√©lectionnez une ou plusieurs colonnes √† ajouter",
    options=df.columns
)
def insert_placeholders_bulk():
    for col in cols_to_insert:
        placeholder = f"{{{col}}}"
        if placeholder not in st.session_state.prompt_text:
            st.session_state.prompt_text += " " + placeholder
st.button("Ajouter tous les placeholders", on_click=insert_placeholders_bulk)

# 4) R√©cup√®re le prompt final
prompt_template = st.session_state.prompt_text

# 5) Validation des placeholders
placeholders = re.findall(r"\{([^}]+)\}", prompt_template)
if not placeholders:
    st.warning("Aucun placeholder d√©tect√© pour le moment.")
invalid = [c for c in placeholders if c not in df.columns]
if invalid:
    st.error(f"Colonnes invalides d√©tect√©es : {', '.join(invalid)}")
    st.stop()

# 6) Pr√©pare la colonne r√©sultat
output_col = st.text_input("Nom de la colonne r√©sultat", "R√©ponse IA")
if output_col not in df.columns:
    df[output_col] = ""

# 7) Configuration de l‚ÄôAPI
model       = st.selectbox("Mod√®le", ["gpt-4o-mini", "gpt-3.5-turbo"])
temperature = st.slider("Temp√©rature", 0.0, 1.0, 0.0)
rate_limit  = st.number_input("Pause entre requ√™tes (s)", min_value=0.0, step=0.1, value=1.0)

# 8) Lancer / Arr√™ter
col1, col2 = st.columns(2)
do_run     = col1.button("‚ñ∂Ô∏è Lancer")
do_stop    = col2.button("‚èπÔ∏è Arr√™ter")
if "stop_flag" not in st.session_state:
    st.session_state.stop_flag = False
if do_stop:
    st.session_state.stop_flag = True

# **placeholder** pour afficher le DataFrame en live
live_table = st.empty()
progress   = st.empty()

def call_chat(prompt: str) -> str:
    try:
        resp = client.chat.completions.create(
            model=model,
            temperature=temperature,
            messages=[
                {"role": "system", "content": "Vous √™tes un assistant utile et pr√©cis."},
                {"role": "user",   "content": prompt}
            ]
        )
        return resp.choices[0].message.content.strip()
    except Exception as e:
        return f"Erreur API : {e}"

# 9) Boucle de traitement
if do_run:
    st.session_state.stop_flag = False
    for i, row in df.iterrows():
        if st.session_state.stop_flag:
            st.warning("‚ö†Ô∏è Traitement interrompu.")
            break
        if not row.get(output_col):
            data = {c: ("" if pd.isna(v) else str(v)) for c, v in row.items()}
            try:
                filled = prompt_template.format(**data)
            except KeyError as e:
                df.at[i, output_col] = f"Placeholder manquant : {e}"
                continue

            df.at[i, output_col] = call_chat(filled)
            live_table.dataframe(df, height=300)

        progress.text(f"Traitement : {i+1}/{len(df)}")
        time.sleep(rate_limit)

    st.success("‚úÖ Traitement termin√©.")
    progress.empty()
else:
    live_table.dataframe(df, height=300)

# 10) T√©l√©chargement
buf = BytesIO()
df.to_excel(buf, index=False, engine="openpyxl")
buf.seek(0)
st.download_button(
    "üíæ T√©l√©charger les r√©sultats",
    data=buf,
    file_name="output.xlsx",
    mime="application/vnd.openxmlformats-officedocument-spreadsheetml.sheet"
)
